\documentclass[a4paper,11pt,english,openany,oneside]{memoir}
\usepackage{universityreport}

\date{December 2011}

\newcommand{\mytitle}{Documentation of Engine}
\newcommand{\mysubject}{Game Engines}

\newcommand{\emil}  {Emil Erik Hansen\xspace}
\newcommand{\julian}{Julian Møller\xspace}
\newcommand{\mads}	{Mads Johansen\xspace}
\newcommand{\rene}  {René Bech Korsgaard\xspace}
\newcommand{\steen} {Steen Nordsmark Pedersen\xspace}

\preauthor{
  \begin{center}
  \footnotesize
  Written by: \\
  \vspace{1em}
  \begin{tabular}{lll}
}

\author{
    \emil & 14-06-85 & \email{emha@itu.dk} \\
    \julian & 18-03-87 & \email{jumo@itu.dk} \\
    \mads & 22-05-85 & \email{madj@itu.dk} \\
    \rene & 28-05-84 & \email{reko@itu.dk} \\
    \steen & 15-02-87 & \email{snop@itu.dk}
}

\postauthor{
  \end{tabular}\\
  \vspace{2em}
  \footnotesize
  Group: \textbf{Warm Tenderized Fudge} \\
  \vspace{8em}
  IT University of Copenhagen \\
  December 2011
  \end{center}
}
\title{\mytitle}

\let\oldpartnumberline\partnumberline

\begin{document}
\frontmatter
\preamble

\mainmatter

\renewcommand{\partname}{}
\renewcommand{\printpartnum}{}
\renewcommand{\thepart}{}

% Consider finding a more suiting section-name might be better (``Requirements''?).
\chapter{Formalities}
The engine was the product of the course \textit{Game Engines}, at the \textit{IT University of Copenhagen}, Fall of 2011. % More bla bla?

In this documentation, the engine is described according to the requirements specified in the two following sections.

\section{Documentation Requirements}
The following were required to be included in the documentation. The various chapters and sections are structured in such a way that it should be fairly easy to quickly find the needed information, based on the requirements.
\begin{itemize}
	\item \textbf{Engine Scope}: Does it target a specific genre? What range of games do you have in mind that the engine would be suitable for? \\ \textit{(\secRef{sec:EngineScope})}
	\item \textbf{Major Features}: What are the main features your engine supports? \\ \textit{(\secRef{sec:MajorFeatures})}
	\item \textbf{Implementation Overview}: Give a high-level explanation of how the engine is structured (perhaps with an architecture diagram). Then, give at least brief explanations of how the major subsystems work, delving into more details for components that are particularly interesting, advanced, or unusual. \textit{(\secRef{sec:ImplementationOverview})}
	\item \textbf{Design Rationales}: Were some of the design decisions made after considering alternatives, and do you have rationales for why you made the decisions you did? If so, tell us! \textit{(\secRef{sec:DesignRationales})}
	\item \textbf{Examples}: Give some examples illustrating interesting features of your engine and how they'd be used. Depending on the features, these can take the form of screenshots, code snippets, flow charts, and/or prose explanation. \textit{(\secRef{sec:Examples})}
\end{itemize}

\section{Engine Requirements}
The following describes the actual requirements of the engine. For each, a reference to the section and page in which it is described is given.

\subsection{A Unique/Advanced Element}
The feature ``Performance Logging'' is described in \secRef{sec:PerformanceLogging}.
\begin{itemize}
	\item Pick either one area of the engine to add advanced functionality to, or at least one optional feature to add. For example: a user-programmable shader interface, procedural terrain, advanced physics, an audio subsystem, etc.
\end{itemize}

\subsection{Dynamic Elements}
Described in \secRef{sec:DynamicElements}.
\begin{itemize}
	\item \textit{Physics and animation}: What makes sense for your engine and why? Decide on a physics/animation split for your engine, considering its target. Do you want forces, manual animations, parametric curves, something else?
	\item \textit{Collision detection}: have collider surfaces for your objects, with at least basic collision detection. If you need performance (lots of objects), GJK may be best.
	\item \textit{Collision response}, if it makes sense for your genre of game: things like objects bouncing off other objects when they collide.
	\item Be able to \textit{add/remove objects from the game world dynamically}, and update associate data structures.
\end{itemize}

\subsection{Resource Management}
Described in \secRef{sec:ResourceManagement}.
\begin{itemize}
	\item \textit{Singleton class} (or several) managing global engine state.
	\item \textit{Memory-management system}. Design on paper first. Implement at least one kind of custom allocator, e.g. a stack allocator used for per-frame allocations.
	\item Design a \textit{resource/dependency-management system}, both runtime and offline portion (offline includes things like asset conditioning, and level format).
	\item Quickest way to get some resources loading: wrap a library like \\ \url{http://assimp.sourceforge.net}.
\end{itemize}

\subsection{Rendering}
Described in \secRef{sec:Rendering}.
\begin{itemize}
	\item \textit{Object-oriented, scenegraph-based rendering}, that recursively renders objects in the scene.
	\item A \textit{camera component} should be present.
	\item Use a method of \textit{speeding up rendering} by retaining data on the GPU. For now display lists are okay, but vertex buffers are better (and will be useful later).
	\item \textit{Lighting manager} (or data structures) storing information on lights in the scene.
	\item \textit{Material properties} on objects.
	\item \textit{Textures} on objects.
	\item \textit{Shaders}: Optional. A user-programmable shader API for your engine could be a nice enhancement. But, everyone should understand how shaders work, even if your engine doesn't use them.
\end{itemize}

\subsection{Game Loop}
Described in \secRef{sec:GameLoop}.
\begin{itemize}
	\item Support \textit{framerate-independent game-world updates} (e.g. using deltaT timings).
	\item Implement an \textit{event system} (may be useful to split into several event systems, e.g. an InputManager handling all input events).
\end{itemize}

\subsection{Input}
Described in \secRef{sec:Input}.
\begin{itemize}
	\item Handle \textit{keyboard} input, with at least a few options. For example: event-based input that queues multiple keypresses, and polling-based input that does something while the key is held down.
	\item Handle \textit{mouse} (or joystick/controller) input, with the option for nonlinear mapping.
	\item Connect input to scene in a basic way, e.g. wasd moves an object, mouse moves camera.
\end{itemize}

% The essence of it all.
\chapter{Engine Description}
\label{sec:EngineDescription}
More of an actual light introduction. Description of the engine and what it can be used for. Covers the ideas and design. See the sections below.

\section{Engine Scope}
\label{sec:EngineScope}
% Does it target a specific genre? What range of games do you have in mind that the engine would be suitable for?
The engine targets the ``Hero \texttt{RTS}\footnote{Real-Time Strategy.}''-genre, more commonly known as ``\texttt{MOBA}\footnote{Multiplayer Online Battle Arena.}''. This includes games like \textit{Heroes of Newerth} and \textit{League of Legends}, both heavy inspired by the \textit{WarCraft III} modification \textit{Defense of the Ancients}.

To make our engine achieve the requirements of the genre, it was important to have a clear idea of what expected result should look like. As a good reference, see the example screenshot in \figRef{fig:DRdota2screen}.

\fig[\textwidth]{includes/dota2screen.jpg}{Engine Scope: Screenshot from \textit{DOTA2}.}{fig:DRdota2screen}

As can be seen, the basic graphics are fairly simple. There has to be a flat ground-level upon which the player can be controlled around, along with objects he cannot pass. On top of that, there has to be an interactable \texttt{HUD}\footnote{Heads Up Display.}. The camera will do limited movement, which again will limit the amount of required graphics that needs to be rendered. Furthermore, the avatar of the player has to be able to get from \texttt{A} to \texttt{B}, and be able to pathfind around various obstacles. 

This puts the main focus of the engine on effective handling of mouse events, collision-detection and pathfinding.

% Describe the comparrison to our screenshot. Pretty difficult without a finished screen... but, yeah. I can't think more at this point.

% Here a screen of our own engine should be, for comparing!   
%\fig[\textwidth]{Pictures/enginescreen.jpg}{Screenshot from our Engine, showcading the User Interface.}{fig:DREngineScreen}

\section{Design Rationales}
\label{sec:DesignRationales}
% Were some of the design decisions made after considering alternatives, and do you have rationales for why you made the decisions you did? If so, tell us!

Go into more depth here in regards to what actual design decisions were actually made. Was it \textit{this} or \textit{that}? Why was it better than the other?

\section{Major Features}
\label{sec:MajorFeatures}
% What are the main features your engine supports?

To make our game function optimally for the specific game genre, the main - and most powerful - features are the following:

\begin{itemize}
	\item An effective Mouse Event system.
	\item A \texttt{HUD} that the mouse can interact with.
	\item Effective pathfinding.
\end{itemize}

% The things that makes the engine special, the primary forces and so on. There is no further explanations of what this part should contain.

\chapter{Implementation Overview}
\label{sec:ImplementationOverview}
% Give a high-level explanation of how the engine is structured (perhaps with an architecture diagram). Then, give at least brief explanations of how the major subsystems work, delving into more details for components that are particularly interesting, advanced, or unusual.

More detailed about the structure of the various parts of the engine. The sections below are taken from the requirements of each of the major parts, but might need to be re-structured after that.

\section{Dynamic Elements}
\label{sec:DynamicElements}

\subsection{Physics System}
\label{sec:PhysicsSystem}
% Physics and animation: What makes sense for your engine and why? Decide on a physics/animation split for your engine, considering its target. Do you want forces, manual animations, parametric curves, something else?
% Be able to add/remove objects from the game world dynamically, and update associate data structures.

\subsection{Collision Detection}
\label{sec:CollisionDetection}
% Collision detection: have collider surfaces for your objects, with at least basic collision detection. If you need performance (lots of objects), GJK may be best.
% Collision response, if it makes sense for your genre of game: things like objects bouncing off other objects when they collide.

\section{Resource Management}
\label{sec:ResourceManagement}
% Singleton class (or several) managing global engine state
% Design a resource/dependency-management system, both runtime and offline portion (offline includes things like asset conditioning, and level format).
% Quickest way to get some resources loading: wrap a library like assimp.sourceforge.net

Interesting stuff regarding how Resources in general are being handled - quick introduction, perhaps?

\subsection{Media Manager}
\label{sec:MediaManager}
The \textit{Media Manager} is the tool that is to be used in order to import and access media files for use in the game. Currently, it supports importing of \texttt{.TGA}-files as textures and all the common model formats as 3D models, by using \textit{Assimp}\footnote{See \textit{Assimp} documentation for a full list of supported file formats.}. In the future, audio files will be accessed and imported using the media manager as well. As this manager is a singleton, any media imported using it will readily be available anywhere in the code as long you include \texttt{<Managers/MediaManager>}.

In order to import a resource, one must first create either a model or a texture image and place it in the \texttt{Resource} folder. A container must then be created for it in the \texttt{MediaManager} class (\texttt{Texture*} for textures, and \texttt{Model*} for models). Then in the \texttt{MediaManager.StartUp()} function the resource must be loaded and stored in the aforementioned container using the \texttt{LoadTexture()} or \texttt{ImportAssimpModel()} respectively. Hereafter the imported asset can be accessed from the \texttt{MediaManger} singleton from anywhere within the engine. However, as the scene is actually built in \texttt{SceneData.cpp} and the \texttt{createGraph()} function, one would usually access in here in order to assign it to an object in the scene. Example of the usage can be seen in \secRef{sec:MediaManagerUsage}.

\subsection{Memory Management}
\label{sec:MemoryManagement}
% Memory-management system. Design on paper first. Implement at least one kind of custom allocator, e.g. a stack allocator used for per-frame allocations.
Describe the Stack Allocator and Heap Allocators here. It will be interesting and awesome.

\subsection{Settings Manager}
\label{sec:SettingsManager}
% I think this is a good spot to describe the Settings Manager, as it doesn't really seem to fit in anywhere else.
As every game needs variable settings and options, which should be easy to customize. We decided to keep the data in an external \texttt{XML}-file, so that it is easily changable outside the game. This opens up for the posibility of having a light-weight external tool.

Inside the engine, the \texttt{XML}-file is loaded upon startup and stored as a DOM\footnote{The ``Document Object Model''-standard.} Tree, which is easily traversable and logically structured. In the same way, the tree can be exported back to the \texttt{XML}-file at any given time, and will also do so upon shutting down the engine.

\section{Rendering}
\label{sec:Rendering}
% Object-oriented, scenegraph-based rendering, that recursively renders objects in the scene.
% Use a method of speeding up rendering by retaining data on the GPU. For now display lists are okay, but vertex buffers are better (and will be useful later).
% Material properties on objects
% Textures on objects
% Shaders: Optional. A user-programmable shader API for your engine could be a nice enhancement. But, everyone should understand how shaders work, even if your engine doesnt use them.

\subsection{Camera}
\label{sec:Camera}
% A camera component should be present.

\subsection{LIGHTNING Manager}
\label{sec:LightingManager}
% Lighting manager (or data structures) storing information on lights in the scene
:D

\section{Game Loop}
\label{sec:GameLoop}
% Support framerate-independent game-world updates (e.g. using deltaT timings).
% Implement an event system (may be useful to split into several event systems, e.g. an InputManager handling all input events).

\subsection{Event System}
\label{sec:EventSystem}
% General thoughts about the Event System.

\section{Input}
\label{sec:Input}
% Handle keyboard input, with at least a few options. For example: event-based input that queues multiple keypresses, and polling-based input that does something while the key is held down.
% Handle mouse (or joystick/controller) input, with the option for nonlinear mapping
% Connect input to scene in a basic way, e.g. wasd moves an object, mouse moves camera.

\subsection{Mouse}
\label{sec:Mouse}
%Fairly extensive section, as there is surely lots to be written in regards to how it works (ie, from mouse-coordinates on the screen to coordinates on the HUD/Worldspace, Events, and... whatever more there is. 

\subsection{Keyboard}
\label{sec:Keyboard}
% Again, event system, what the uses are... erh, yeah. Probably not that much to write here, really.

\section{Performance Logging}
\label{sec:PerformanceLogging}
%Pick either one area of the engine to add advanced functionality to, or at least one optional feature to add. For example: a user-programmable shader interface, procedural terrain, advanced physics, an audio subsystem, etc.

Gogo Gadget Mads!

\chapter{Examples}
\label{sec:Examples}
% Give some examples illustrating interesting features of your engine and how theyd be used. Depending on the features, these can take the form of screenshots, code snippets, flow charts, and/or prose explanation.

Giving examples is one of the requirements of the documentation. It could either be done throughout the document, or simply be here in a chapter for itself. Most likely a better idea, to keep it from the more in-depth technical facts.

\section{Media Manager Usage}
\label{sec:MediaManagerUsage}
The Memory Manager (described in \secRef{sec:MediaManager} is used in the following way:

\begin{enumerate}
	\item Firstly two containers, to hold the player's model and its texture, are created. See \figRef{fig:MMUsage1}.
	\item Then the resources are imported in the \texttt{StartUp()} function. See \figRef{fig:MMUsage2}.
	\item And lastly an object is instantiated in the \texttt{createGraph()} function and are assigned the player model that we imported earlier. See \figRef{fig:MMUsage3}.
\end{enumerate}

One might note that the texture is not assigned here. The reason being that it is done automatically when importing the player model as long as the texture is assigned in the model file is called the same as the texture we imported. In this example the name would have to be \texttt{player.tga} or \texttt{PlayerTexture}.

\fig[175px]{includes/MMUsage1.png}{MediaManager Usage, Step 1: Initializing containers.}{fig:MMUsage1}
\fig[430px]{includes/MMUsage2.png}{MediaManager Usage, Step 2: Resources are imported.}{fig:MMUsage2}
\fig[371px]{includes/MMUsage3.png}{MediaManager Usage, Step 3: Object instantiated.}{fig:MMUsage3}

\chapter{Concluding Comments}
\label{sec:ConcludingComments}
Might be a good idea with a minor wrap-up at the end.

Also, a better name could be used for this section - but a fitting alternative is eluding me at this point.

\end{document}
