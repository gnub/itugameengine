\documentclass[a4paper,11pt,english,openany,oneside]{memoir}
\usepackage{universityreport}
\usepackage{pdfpages}

\date{December 2011}

\newcommand{\mytitle}{Documentation of Engine}
\newcommand{\mysubject}{Game Engines}

\newcommand{\emil}  {Emil Erik Hansen\xspace}
\newcommand{\julian}{Julian Møller\xspace}
\newcommand{\mads}	{Mads Johansen\xspace}
\newcommand{\rene}  {René Korsgaard\xspace}
\newcommand{\steen} {Steen Nordsmark Pedersen\xspace}

\preauthor{
  \begin{center}
  \footnotesize
  Written by: \\
  \vspace{1em}
  \begin{tabular}{lll}
}

\author{
    \emil & 14-06-85 & \email{emha@itu.dk} \\
    \julian & 18-03-87 & \email{jumo@itu.dk} \\
    \mads & 22-05-85 & \email{madj@itu.dk} \\
    \rene & 28-05-84 & \email{reko@itu.dk} \\
    \steen & 15-02-87 & \email{snop@itu.dk}
}

\postauthor{
  \end{tabular}\\
  \vspace{2em}
  \footnotesize
  Group: \textbf{Warm Tenderized Fudge} \\
  \vspace{8em}
  IT University of Copenhagen \\
  December 2011
  \end{center}
}
\title{\mytitle}

\let\oldpartnumberline\partnumberline

\begin{document}
\frontmatter
\preamble

\mainmatter

\renewcommand{\partname}{}
\renewcommand{\printpartnum}{}
\renewcommand{\thepart}{}

% Consider finding a more suiting section-name might be better (``Requirements''?).
\chapter{Formalities}
The engine was the product of the course \textit{Game Engines}, at the \textit{IT University of Copenhagen}, Fall of 2011. % More bla bla?

In this documentation, the engine is described according to the requirements specified in the two following sections.

\section{Documentation Requirements}
The following were required to be included in the documentation. The various chapters and sections are structured in such a way that it should be fairly easy to quickly find the needed information, based on the requirements.
\begin{itemize}
	\item \textbf{Engine Scope}: Does it target a specific genre? What range of games do you have in mind that the engine would be suitable for? \\ \textit{(\secRef{sec:EngineScope})}
	\item \textbf{Major Features}: What are the main features your engine supports? \\ \textit{(\secRef{sec:MajorFeatures})}
	\item \textbf{Implementation Overview}: Give a high-level explanation of how the engine is structured (perhaps with an architecture diagram). Then, give at least brief explanations of how the major subsystems work, delving into more details for components that are particularly interesting, advanced, or unusual. \textit{(\secRef{sec:ImplementationOverview})}
	\item \textbf{Design Rationales}: Were some of the design decisions made after considering alternatives, and do you have rationales for why you made the decisions you did? If so, tell us! \textit{(\secRef{sec:DesignRationales})}
	\item \textbf{Examples}: Give some examples illustrating interesting features of your engine and how they'd be used. Depending on the features, these can take the form of screenshots, code snippets, flow charts, and/or prose explanation. \textit{(\secRef{sec:Examples})}
\end{itemize}

\section{Engine Requirements}
The following describes the actual requirements of the engine. For each, a reference to the section and page in which it is described is given.

\subsection{A Unique/Advanced Element}
The feature ``Performance Logging'' is described in \secRef{sec:PerformanceLogging}.
\begin{itemize}
	\item Pick either one area of the engine to add advanced functionality to, or at least one optional feature to add. For example: a user-programmable shader interface, procedural terrain, advanced physics, an audio subsystem, etc.
\end{itemize}

\subsection{Dynamic Elements}
Described in \secRef{sec:DynamicElements}.
\begin{itemize}
	\item \textit{Physics and animation}: What makes sense for your engine and why? Decide on a physics/animation split for your engine, considering its target. Do you want forces, manual animations, parametric curves, something else?
	\item \textit{Collision detection}: have collider surfaces for your objects, with at least basic collision detection. If you need performance (lots of objects), GJK may be best.
	\item \textit{Collision response}, if it makes sense for your genre of game: things like objects bouncing off other objects when they collide.
	\item Be able to \textit{add/remove objects from the game world dynamically}, and update associate data structures.
\end{itemize}

\subsection{Resource Management}
Described in \secRef{sec:ResourceManagement}.
\begin{itemize}
	\item \textit{Singleton class} (or several) managing global engine state.
	\item \textit{Memory-management system}. Design on paper first. Implement at least one kind of custom allocator, e.g. a stack allocator used for per-frame allocations.
	\item Design a \textit{resource/dependency-management system}, both runtime and offline portion (offline includes things like asset conditioning, and level format).
	\item Quickest way to get some resources loading: wrap a library like \\ \url{http://assimp.sourceforge.net}.
\end{itemize}

\subsection{Rendering}
Described in \secRef{sec:Rendering}.
\begin{itemize}
	\item \textit{Object-oriented, scenegraph-based rendering}, that recursively renders objects in the scene.
	\item A \textit{camera component} should be present.
	\item Use a method of \textit{speeding up rendering} by retaining data on the GPU. For now display lists are okay, but vertex buffers are better (and will be useful later).
	\item \textit{Lighting manager} (or data structures) storing information on lights in the scene.
	\item \textit{Material properties} on objects.
	\item \textit{Textures} on objects.
	\item \textit{Shaders}: Optional. A user-programmable shader API for your engine could be a nice enhancement. But, everyone should understand how shaders work, even if your engine doesn't use them.
\end{itemize}

\subsection{Game Loop}
Described in \secRef{sec:GameLoop}.
\begin{itemize}
	\item Support \textit{framerate-independent game-world updates} (e.g. using deltaT timings).
	\item Implement an \textit{event system} (may be useful to split into several event systems, e.g. an InputManager handling all input events).
\end{itemize}

\subsection{Input}
Described in \secRef{sec:Input}.
\begin{itemize}
	\item Handle \textit{keyboard} input, with at least a few options. For example: event-based input that queues multiple keypresses, and polling-based input that does something while the key is held down.
	\item Handle \textit{mouse} (or joystick/controller) input, with the option for nonlinear mapping.
	\item Connect input to scene in a basic way, e.g. wasd moves an object, mouse moves camera.
\end{itemize}

% The essence of it all.
\chapter{Engine Description}
\label{sec:EngineDescription}
More of an actual light introduction. Description of the engine and what it can be used for. Covers the ideas and design. See the sections below.

\section{Engine Scope}
\label{sec:EngineScope}
% Does it target a specific genre? What range of games do you have in mind that the engine would be suitable for?
The engine targets the ``Hero \texttt{RTS}\footnote{Real-Time Strategy.}''-genre, more commonly known as ``\texttt{MOBA}\footnote{Multiplayer Online Battle Arena.}''. This includes games like \textit{Heroes of Newerth} and \textit{League of Legends}, both heavy inspired by the \textit{WarCraft III} modification \textit{Defense of the Ancients}.

To make our engine achieve the requirements of the genre, it was important to have a clear idea of what expected result should look like. As a good reference, see the example screenshot in \figRef{fig:DRdota2screen}.

\fig[\textwidth]{Pictures/dota2screen.jpg}{Screenshot from \textit{DOTA2}, showcasing the idea we wanted to achieve.}{fig:DRdota2screen}

As can be seen, the basic graphics are fairly simple. There has to be a flat ground-level upon which the player can be controlled around, along with objects he cannot pass. On top of that, there has to be an interactable \texttt{HUD}\footnote{Heads Up Display.}. The camera will do limited movement, which again will limit the amount of required graphics that needs to be rendered. Furthermore, the avatar of the player has to be able to get from \texttt{A} to \texttt{B}, and be able to pathfind around various obstacles. 

This puts the main focus of the engine on effective handling of mouse events, collision-detection and pathfinding.

% Describe the comparrison to our screenshot. Pretty difficult without a finished screen... but, yeah. I can't think more at this point.

% Here a screen of our own engine should be, for comparing!   
%\fig[\textwidth]{Pictures/enginescreen.jpg}{Screenshot from our Engine, showcading the User Interface.}{fig:DREngineScreen}

\section{Design Rationales}
\label{sec:DesignRationales}
% Were some of the design decisions made after considering alternatives, and do you have rationales for why you made the decisions you did? If so, tell us!

Go into more depth here in regards to what actual design decisions were actually made. Was it \textit{this} or \textit{that}? Why was it better than the other?

\section{Major Features}
\label{sec:MajorFeatures}
% What are the main features your engine supports?

To make our game function optimally for the specific game genre, the main - and most powerful - features are the following:

\begin{itemize}
	\item An effective Mouse Event system.
	\item A \texttt{HUD} that the mouse can interact with.
	\item Effective pathfinding.
\end{itemize}

% The things that makes the engine special, the primary forces and so on. There is no further explanations of what this part should contain.

\chapter{Implementation Overview}
\label{sec:ImplementationOverview}
% Give a high-level explanation of how the engine is structured (perhaps with an architecture diagram). Then, give at least brief explanations of how the major subsystems work, delving into more details for components that are particularly interesting, advanced, or unusual.

More detailed about the structure of the various parts of the engine. The sections below are taken from the requirements of each of the major parts, but might need to be re-structured after that.

\section{Dynamic Elements}
\label{sec:DynamicElements}
% Physics and animation: What makes sense for your engine and why? Decide on a physics/animation split for your engine, considering its target. Do you want forces, manual animations, parametric curves, something else?
% Collision detection: have collider surfaces for your objects, with at least basic collision detection. If you need performance (lots of objects), GJK may be best.
% Collision response, if it makes sense for your genre of game: things like objects bouncing off other objects when they collide.
% Be able to add/remove objects from the game world dynamically, and update associate data structures.

\section{Resource Management}
\label{sec:ResourceManagement}
% Singleton class (or several) managing global engine state
% Memory-management system. Design on paper first. Implement at least one kind of custom allocator, e.g. a stack allocator used for per-frame allocations.
% Design a resource/dependency-management system, both runtime and offline portion (offline includes things like asset conditioning, and level format).
% Quickest way to get some resources loading: wrap a library like assimp.sourceforge.net

\subsection{Settings Manager}
\label{sec:SettingsManager}
% I think this is a good spot to describe the Settings Manager, as it doesn't really seem to fit in anywhere else.
As every game needs variable settings and options, which should be easy to customize. We decided to keep the data in an external \texttt{XML}-file, so that it is easily changable outside the game. This opens up for the posibility of having a light-weight external tool.

Inside the engine, the \texttt{XML}-file is loaded upon startup and stored as a DOM\footnote{The ``Document Object Model''-standard.} Tree, which is easily traversable and logically structured. In the same way, the tree can be exported back to the \texttt{XML}-file at any given time, and will also do so upon shutting down the engine.

\section{Rendering}
\label{sec:Rendering}
% Object-oriented, scenegraph-based rendering, that recursively renders objects in the scene.
% A camera component should be present.
% Use a method of speeding up rendering by retaining data on the GPU. For now display lists are okay, but vertex buffers are better (and will be useful later).
% Lighting manager (or data structures) storing information on lights in the scene
% Material properties on objects
% Textures on objects
% Shaders: Optional. A user-programmable shader API for your engine could be a nice enhancement. But, everyone should understand how shaders work, even if your engine doesnt use them.

\section{Game Loop}
\label{sec:GameLoop}
% Support framerate-independent game-world updates (e.g. using deltaT timings).
% Implement an event system (may be useful to split into several event systems, e.g. an InputManager handling all input events).

\section{Input}
\label{sec:Input}
% Handle keyboard input, with at least a few options. For example: event-based input that queues multiple keypresses, and polling-based input that does something while the key is held down.
% Handle mouse (or joystick/controller) input, with the option for nonlinear mapping
% Connect input to scene in a basic way, e.g. wasd moves an object, mouse moves camera.

\section{Performance Logging}
\label{sec:PerformanceLogging}
%Pick either one area of the engine to add advanced functionality to, or at least one optional feature to add. For example: a user-programmable shader interface, procedural terrain, advanced physics, an audio subsystem, etc.

\chapter{Examples}
\label{sec:Examples}
% Give some examples illustrating interesting features of your engine and how theyd be used. Depending on the features, these can take the form of screenshots, code snippets, flow charts, and/or prose explanation.

Giving examples is one of the requirements of the documentation. It could either be done throughout the document, or simply be here in a chapter for itself. Most likely a better idea, to keep it from the more in-depth technical facts.

\chapter{Concluding Comments}
\label{sec:ConcludingComments}
Might be a good idea with a minor wrap-up at the end.

Also, a better name could be used for this section - but a fitting alternative is eluding me at this point.

\end{document}
